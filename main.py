import concurrent.futures
from modules.sql_injection import check_sql_injection
from modules.xss import check_xss
from modules.directory_listing import check_directory_listing
from modules.insecure_headers import check_insecure_headers
from modules.open_ports import check_open_ports
from modules.csrf import check_csrf
from modules.logging import log_vulnerability
from modules.reporting import generate_report

def scan_url(url):
    vulnerabilities = []
    try:
        sql_vulns = check_sql_injection(url)
        xss_vulns = check_xss(url)
        dir_vulns = check_directory_listing(url)
        hdr_vulns = check_insecure_headers(url)
        csrf_vulns = check_csrf(url)
        all_vulns = sql_vulns + xss_vulns + dir_vulns + hdr_vulns + csrf_vulns
        vulnerabilities.extend(all_vulns)

        for vuln in all_vulns:
            log_vulnerability(vuln.split(" ")[1], url, vuln)
    except Exception as e:
        print(f"Error scanning {url}: {e}")
    return vulnerabilities

def main():
    urls = ["http://example.com", "http://testsite.com"]
    all_vulnerabilities = []

    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        future_to_url = {executor.submit(scan_url, url): url for url in urls}
        for future in concurrent.futures.as_completed(future_to_url):
            url = future_to_url[future]
            try:
                vulnerabilities = future.result()
                all_vulnerabilities.extend(vulnerabilities)
            except Exception as e:
                print(f"Error scanning {url}: {e}")

    generate_report(all_vulnerabilities)

if __name__ == "__main__":
    main()


